import os
import sqlparse
import cx_Oracle
from flask import Flask, render_template, request, jsonify
from llama_cpp import Llama
from rules import apply_rules

app = Flask(__name__)

# --- Configuration ---
DB_CONFIG = {
    'host': 'localhost',
    'port': 1521,
    'sid': 'orcl',      
    'user': 'AFNAN',   
    'password': 'AFNAN' 
}

MODEL_CONFIG = {
    'model_path': os.path.abspath('model/sqlcoder-7b.Q4_K_M.gguf'),
    'n_ctx': 2048,
    'n_threads': 8,
    'n_gpu_layers': 0
}

PROMPT_TEMPLATE = """
### Task
Generate a SQL query to answer the following question:
\"\"\"{question}\"\"\"

### Database Schema
{schema_ddl}

### Answer
Given the database schema, here is the SQL query:
"""

# --- Utility Functions ---
def get_dsn():
    return cx_Oracle.makedsn(
        DB_CONFIG['host'],
        DB_CONFIG['port'],
        sid=DB_CONFIG['sid']
    )

def connect_oracle():
    return cx_Oracle.connect(
        user=DB_CONFIG['user'],
        password=DB_CONFIG['password'],
        dsn=get_dsn()
    )

def get_all_databases():
    conn = connect_oracle()
    cursor = conn.cursor()
    cursor.execute("SELECT username FROM all_users ORDER BY username")
    schemas = [row[0] for row in cursor.fetchall()]
    cursor.close()
    conn.close()
    return schemas

def get_schema(conn):
    ddl = []
    cursor = conn.cursor()
    cursor.execute("SELECT table_name FROM user_tables")
    tables = [row[0] for row in cursor.fetchall()]
    for table in tables:
        cursor.execute("""
            SELECT column_name, data_type
            FROM user_tab_columns
            WHERE table_name = :tname
        """, {"tname": table})
        columns = cursor.fetchall()
        column_defs = ", ".join([f"{col} {dtype}" for col, dtype in columns])
        # Removed semicolon at the end to avoid ORA-00911
        ddl.append(f"CREATE TABLE {table} ({column_defs})")
    cursor.close()
    return "\n".join(ddl), tables

def generate_sql(prompt):
    llm = Llama(
        model_path=MODEL_CONFIG['model_path'],
        n_ctx=MODEL_CONFIG['n_ctx'],
        n_threads=MODEL_CONFIG['n_threads'],
        n_gpu_layers=MODEL_CONFIG['n_gpu_layers'],
        verbose=False
    )
    response = llm(prompt, max_tokens=256)
    sql_raw = response['choices'][0]['text'].strip()
    return sqlparse.format(sql_raw, reindent=False, keyword_case='upper')

def execute_query(conn, sql):
    sql = sql.strip().rstrip(';')  # Ensure no trailing semicolon
    cursor = conn.cursor()
    try:
        cursor.execute(sql)
        try:
            rows = cursor.fetchall()
            columns = [desc[0] for desc in cursor.description]
        except cx_Oracle.InterfaceError:
            rows = []
            columns = []
        conn.commit()
        cursor.close()
        return {"rows": rows, "columns": columns}
    except Exception as e:
        cursor.close()
        return f"‚ùå Query failed: {e}"

def ensure_tables_exist(conn):
    cursor = conn.cursor()

    # Detect Oracle version
    cursor.execute("SELECT banner FROM v$version")
    version_info = " ".join([row[0] for row in cursor.fetchall()])
    supports_identity = any(ver in version_info for ver in ["Release 12", "Release 19", "Release 21"])

    # Check existing tables
    cursor.execute("""
        SELECT table_name FROM user_tables
        WHERE table_name IN ('CORRECT_QUERIES', 'HISTORY')
    """)
    existing = {row[0] for row in cursor.fetchall()}

    # CORRECT_QUERIES
    if 'CORRECT_QUERIES' not in existing:
        if supports_identity:
            cursor.execute("""
                CREATE TABLE correct_queries (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    database_name VARCHAR2(200),
                    question CLOB,
                    confirmed_sql CLOB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
        else:
            cursor.execute("""
                CREATE TABLE correct_queries (
                    id NUMBER PRIMARY KEY,
                    database_name VARCHAR2(200),
                    question CLOB,
                    confirmed_sql CLOB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            cursor.execute("CREATE SEQUENCE correct_queries_seq START WITH 1 INCREMENT BY 1")
            cursor.execute("""
                CREATE OR REPLACE TRIGGER correct_queries_bir
                BEFORE INSERT ON correct_queries
                FOR EACH ROW
                WHEN (new.id IS NULL)
                BEGIN
                    SELECT correct_queries_seq.NEXTVAL INTO :new.id FROM dual;
                END;
            """)

    # HISTORY
    if 'HISTORY' not in existing:
        if supports_identity:
            cursor.execute("""
                CREATE TABLE history (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    database_name VARCHAR2(200),
                    question CLOB,
                    generated_sql CLOB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
        else:
            cursor.execute("""
                CREATE TABLE history (
                    id NUMBER PRIMARY KEY,
                    database_name VARCHAR2(200),
                    question CLOB,
                    generated_sql CLOB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            cursor.execute("CREATE SEQUENCE history_seq START WITH 1 INCREMENT BY 1")
            cursor.execute("""
                CREATE OR REPLACE TRIGGER history_bir
                BEFORE INSERT ON history
                FOR EACH ROW
                WHEN (new.id IS NULL)
                BEGIN
                    SELECT history_seq.NEXTVAL INTO :new.id FROM dual;
                END;
            """)

    conn.commit()
    cursor.close()

def get_all_history():
    history_list = []
    try:
        conn = connect_oracle()
        ensure_tables_exist(conn)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, question, created_at
            FROM history
            ORDER BY created_at DESC
        """)
        for row in cursor.fetchall():
            history_list.append((
                "Oracle", 
                row[0], 
                str(row[1]) if row[1] is not None else "",
                row[2]
            ))
        cursor.close()
        conn.close()
    except Exception:
        pass
    history_list.sort(key=lambda x: x[3], reverse=True)
    return [{"db": row[0], "id": row[1], "question": row[2]} for row in history_list]

# --- Flask Routes ---
@app.route('/', methods=['GET', 'POST'])
def index():
    result = ''
    sql = ''
    question = ''
    selected_db = ''
    history_items = []
    databases = get_all_databases()

    if request.method == 'POST':
        question = request.form['question']
        selected_db = request.form['database']
        conn = connect_oracle()

        ensure_tables_exist(conn)

         # üîπ Apply rules from rules.py
        question_converted = apply_rules(question)

        # üîπ Check for a similar question in history
        cursor = conn.cursor()
        cursor.execute("""
            SELECT generated_sql
            FROM history
            WHERE LOWER(question) LIKE LOWER(:q)
            ORDER BY created_at DESC
        """, {"q": f"%{question_converted}%"})
        row = cursor.fetchone()
        cursor.close()

        if row:
            # Use the stored SQL if similar question found
            prev_sql = row[0]
            sql = prev_sql.read() if hasattr(prev_sql, 'read') else prev_sql
            # ‚úÖ Save this run into history too
            save_combine_query(conn, selected_db, question, sql)
        else:
            # No similar question ‚Üí generate a new one
            schema, _ = get_schema(conn)
            prompt = PROMPT_TEMPLATE.format(question=question_converted, schema_ddl=schema)
            sql = generate_sql(prompt)
            save_combine_query(conn, selected_db, question, sql)


        result = execute_query(conn, sql)
        history_items = get_all_history()
        conn.close()

    else:
        history_items = get_all_history()
        if databases:
            selected_db = databases[0]

    return render_template(
        'index.html',
        question=question,
        sql=sql,
        result=result,
        databases=databases,
        selected_db=selected_db,
        history_items=history_items
    )


@app.route('/delete_history/<db_name>/<int:history_id>', methods=['POST'])
def delete_history(db_name, history_id):
    try:
        conn = connect_oracle()
        ensure_tables_exist(conn)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM history WHERE id = :id", {"id": history_id})
        if cursor.rowcount == 0:
            cursor.close()
            conn.close()
            return jsonify({"status": "error", "message": "History item not found."}), 404
        conn.commit()
        cursor.close()
        conn.close()
        return jsonify({"status": "success"})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

def save_combine_query(conn, db_name, question, generated_sql):
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO history (database_name, question, generated_sql)
        VALUES (:db, :q, :sql)
    """, {"db": db_name, "q": question, "sql": generated_sql})
    conn.commit()
    cursor.close()

def save_correct_query(conn, db_name, question, confirmed_sql):
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO correct_queries (database_name, question, confirmed_sql)
        VALUES (:db, :q, :sql)
    """, {"db": db_name, "q": question, "sql": confirmed_sql})
    conn.commit()
    cursor.close()

def find_similar_query(conn, question):
    """
    Checks if a similar question already exists in history.
    """
    cursor = conn.cursor()
    cursor.execute("""
        SELECT id, question, generated_sql
        FROM history
        WHERE LOWER(question) LIKE LOWER(:q)
        ORDER BY created_at DESC
    """, {"q": f"%{question}%"})
    row = cursor.fetchone()
    cursor.close()
    return row  # returns (id, question, sql) or None


@app.route('/history_item/<db_name>/<int:history_id>', methods=['GET'])
def get_history_item(db_name, history_id):
    try:
        conn = connect_oracle()
        ensure_tables_exist(conn)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT question, generated_sql
            FROM history
            WHERE id = :id
        """, {"id": history_id})
        row = cursor.fetchone()

        if not row:
            cursor.close()
            conn.close()
            return jsonify({"status": "error", "message": "History item not found"}), 404

        question, generated_sql = row

        # ‚úÖ Read LOB data before closing connection
        if hasattr(question, 'read'):
            question = question.read()
        if hasattr(generated_sql, 'read'):
            generated_sql = generated_sql.read()

        cursor.close()
        conn.close()

        return jsonify({
            "status": "success",
            "question": question,
            "generated_sql": generated_sql
        })
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/confirm', methods=['POST'])
def confirm():
    is_correct = request.form.get("is_correct")
    if is_correct != 'yes':
        return jsonify({"status": "ignored"})

    db_name = request.form.get("database")
    question = request.form.get("question")
    confirmed_sql = request.form.get("confirmed_sql")

    try:
        conn = connect_oracle()
        ensure_tables_exist(conn)
        save_correct_query(conn, db_name, question, confirmed_sql)
        conn.close()
        return jsonify({"status": "success"})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)})

# --- Run App ---
if __name__ == '__main__':
    app.run(debug=True)
